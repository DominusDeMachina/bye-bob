# Task ID: 2
# Title: Database Schema Design and Migration System
# Status: in-progress
# Dependencies: 1
# Priority: high
# Description: Design and implement a robust, version-controlled database schema in Supabase (PostgreSQL) using modern Go practices. The solution should leverage golang-migrate for managing schema migrations, ensure best practices for schema evolution, and support maintainable, scalable development workflows.

Key requirements:
- Set up a Supabase project and configure PostgreSQL connection
- Use golang-migrate to manage migration files and apply schema changes, enabling version control and repeatable deployments[5][2]
- Design the schema with clear table definitions, relationships, and constraints for core entities:
  - employees (id, first_name, middle_name, last_name, display_name, email, address, position_id, department_id, site_id, manager_id, employment_type, start_date, end_date, status, profile_picture_url)
  - positions (id, title, description, requirements)
  - departments (id, name, description, lead_id)
  - sites (id, name, city, address)
  - assessment_templates (id, name, description, version, active)
  - assessments (id, template_id, employee_id, reviewer_id, status, created_at, completed_at)
  - goals (id, employee_id, title, description, time_frame, type, status, created_at, updated_at)
  - goal_checkins (id, goal_id, note, progress, created_at)
  - audit_logs (id, user_id, action, table_name, record_id, changes, created_at)
- Establish foreign key relationships, constraints, and indexes for data integrity and performance
- Configure Row Level Security (RLS) policies in Supabase for granular access control
- Implement a PostgreSQL connection pool using pgxpool for efficient resource management
- Apply the repository pattern in Go to abstract database access, promote testability, and support clean architecture
- Document schema changes and migration processes for team collaboration

The implementation should follow modern Go conventions for database access, migration management, and schema design, ensuring maintainability and scalability for future development[5][2].
# Details:
1. Set up Supabase project and configure PostgreSQL connection
2. Implement migration system using golang-migrate, ensuring all schema changes are tracked and versioned[5][2]
3. Create initial migration files for core tables as specified
4. Define foreign key relationships and constraints for data integrity
5. Implement indexes on frequently queried columns for performance optimization
6. Configure Row Level Security (RLS) policies in Supabase for secure access control
7. Set up a PostgreSQL connection pool using pgxpool for efficient database connections
8. Implement the repository pattern in Go to abstract and organize database operations, supporting maintainable and testable code
9. Document migration and schema management processes for developer onboarding and collaboration

# Test Strategy:
1. Test migration up and down functionality using golang-migrate
2. Verify all tables are created with correct columns, relationships, and constraints
3. Test foreign key constraints and cascading actions with sample data
4. Validate that indexes improve query performance on key operations
5. Test RLS policies with different user roles to ensure correct access control
6. Benchmark connection pool performance under simulated load
7. Unit test repository layer methods for CRUD operations and error handling

# Subtasks:
## 1. Set up Supabase project and PostgreSQL connection [done]
### Dependencies: None
### Description: Create a Supabase project and configure PostgreSQL connection settings for the application
### Details:
1. Create a new Supabase project using the Supabase Dashboard
2. Configure PostgreSQL connection settings in the application
3. Set up environment variables for database credentials
4. Test the connection to ensure it works correctly
5. Document the setup process for team members
<info added on 2025-05-19T20:44:08.716Z>
1. Create a new Supabase project using the Supabase Dashboard
2. Configure PostgreSQL connection settings in the application
3. Set up environment variables for database credentials
4. Test the connection to ensure it works correctly
5. Document the setup process for team members

Implementation details:
- Created a database connection package with pgxpool integration in internal/database/db.go
- Implemented connection pooling with appropriate settings for optimal performance
- Added connection retry and health check functionality to ensure database reliability
- Created comprehensive documentation:
  - Supabase setup guide in docs/supabase_setup.md
  - Database setup instructions in docs/database_setup.md
- Set up migration system infrastructure with golang-migrate (preparing for next subtask)
- Added Makefile targets for common database operations
- Created scripts:
  - Migration initialization script (scripts/setup_migrations.sh)
  - Test script to verify Supabase/PostgreSQL connection
- Established repository pattern:
  - Defined repository interfaces in internal/repository/interfaces.go
  - Implemented clean separation of concerns for database operations

The implementation follows best practices for PostgreSQL connection management with proper error handling and connection pooling strategies.
</info added on 2025-05-19T20:44:08.716Z>

## 2. Implement migration system with golang-migrate [pending]
### Dependencies: 2.1
### Description: Set up golang-migrate to manage database schema migrations in a version-controlled way
### Details:
1. Install golang-migrate CLI tool
2. Create a migrations directory structure
3. Set up migration commands in the Makefile
4. Configure the migration system to work with PostgreSQL
5. Create basic migration templates
6. Document the migration workflow for the team

## 3. Design and create core entity tables [pending]
### Dependencies: 2.2
### Description: Design and implement the core entity tables including employees, positions, departments, and sites
### Details:
1. Create migration files for employee-related entities:
   - employees (id, first_name, middle_name, last_name, display_name, email, address, position_id, department_id, site_id, manager_id, employment_type, start_date, end_date, status, profile_picture_url)
   - positions (id, title, description, requirements)
   - departments (id, name, description, lead_id)
   - sites (id, name, city, address)
2. Define appropriate data types and constraints
3. Add foreign key relationships between tables
4. Create indexes for frequently queried columns
5. Run and test the migrations
6. Document the schema design

## 4. Create assessment and goal-related tables [pending]
### Dependencies: 2.3
### Description: Design and implement the assessment and goal-related tables for performance management
### Details:
1. Create migration files for assessment and goal-related entities:
   - assessment_templates (id, name, description, version, active)
   - assessments (id, template_id, employee_id, reviewer_id, status, created_at, completed_at)
   - goals (id, employee_id, title, description, time_frame, type, status, created_at, updated_at)
   - goal_checkins (id, goal_id, note, progress, created_at)
2. Define appropriate data types and constraints
3. Add foreign key relationships to employees and other tables
4. Create indexes for frequently queried columns
5. Run and test the migrations
6. Document the schema design

## 5. Set up audit logging and system tables [pending]
### Dependencies: 2.4
### Description: Implement audit logging and system utility tables for tracking changes
### Details:
1. Create migration files for audit and system tables:
   - audit_logs (id, user_id, action, table_name, record_id, changes, created_at)
   - Create any additional system tables needed for application functionality
2. Set up triggers or hooks for automatically logging changes
3. Define appropriate data types and constraints
4. Create indexes for audit table queries
5. Run and test the migrations
6. Document the audit logging system

## 6. Configure Row Level Security policies [pending]
### Dependencies: 2.5
### Description: Set up Row Level Security (RLS) policies in Supabase for granular access control
### Details:
1. Design RLS policies for each table based on user roles and permissions
2. Implement RLS policies in Supabase for:
   - Employees (managers can see their team members)
   - Departments (department heads can manage their departments)
   - Assessments (reviewers can see assessments they're assigned to)
   - Goals (employees can see their own goals, managers can see their team's goals)
3. Test the RLS policies with different user roles
4. Document all RLS policies for future reference

## 7. Implement database connection pool [pending]
### Dependencies: 2.6
### Description: Set up a PostgreSQL connection pool using pgxpool for efficient database connections
### Details:
1. Configure a PostgreSQL connection pool using pgxpool
2. Set up appropriate connection pool parameters (max connections, idle timeout, etc.)
3. Create a shared database package that exposes the connection pool
4. Implement connection retry logic and error handling
5. Add health checks for database connections
6. Document the connection pool configuration for the team

## 8. Create repository layer for data access [pending]
### Dependencies: 2.7
### Description: Implement the repository pattern in Go to abstract and organize database operations
### Details:
1. Design repository interfaces for each domain entity (Employee, Department, Position, etc.)
2. Implement PostgreSQL-specific repository implementations using pgx
3. Create CRUD operations for each entity
4. Add query methods for common access patterns
5. Implement transaction support for multi-table operations
6. Add proper error handling and logging
7. Write unit tests for repository methods
8. Document the repository pattern implementation

